#ifndef _COMMONEVENT_H_
#define _COMMONEVENT_H_

namespace XCommonEvent
{
enum
{
	eGame = 0,
	eGameEnd = 49,
	eUI = 50,
	eUIEnd = 149,
	eScript = 150,
	eScriptEnd = 255,

	eEventMaxNum,
};

static const char* g_szEventName[XCommonEvent::eEventMaxNum] = {NULL};
#define REG_EVENT_TYPE(type, nId, EventName)\
	enum { EventName = type + nId };\
	static const char* _szInst##EventName = g_szEventName[EventName] = #EventName;\

// 心跳包
REG_EVENT_TYPE(eGame, 0, HEARTBEAT_REQ);
// 位置信息
REG_EVENT_TYPE(eGame, 1, CITYPOS_REQ);
//在副本中死亡后
REG_EVENT_TYPE(eGame, 3, IZ_ONDEAD);
//完成副本
REG_EVENT_TYPE(eGame, 4, IZ_LASTSTAGEFINISH);
//链接服务器失败
REG_EVENT_TYPE(eGame, 5, CONNECTSERVER_FAILD);
//进入主城的消息
REG_EVENT_TYPE(eGame, 6, CITYENTER);
// 进入副本的消息
REG_EVENT_TYPE(eGame, 7, CITYIZMAP);
// 主城点击到自己
REG_EVENT_TYPE(eGame, 8, CITY_TOUCH_ME);
// 主城点击到其他玩家
REG_EVENT_TYPE(eGame, 9, CITY_TOUCH_OP);
// 主城点击到NPC
REG_EVENT_TYPE(eGame, 10, CITY_TOUCH_NPC);
// 掉线了
REG_EVENT_TYPE(eGame, 11, DISCONNECT_EVENT);

// 每个ui层事件
REG_EVENT_TYPE(eGame, 12, LAYEREVENT_0);
REG_EVENT_TYPE(eGame, 13, LAYEREVENT_1);
REG_EVENT_TYPE(eGame, 14, LAYEREVENT_2);
REG_EVENT_TYPE(eGame, 15, LAYEREVENT_3);
REG_EVENT_TYPE(eGame, 16, LAYEREVENT_4);
REG_EVENT_TYPE(eGame, 17, LAYEREVENT_5);
REG_EVENT_TYPE(eGame, 18, LAYEREVENT_6);

REG_EVENT_TYPE(eGame, 19, SKILL_UP);
REG_EVENT_TYPE(eGame, 20, SKILL_DOWN);
REG_EVENT_TYPE(eGame, 21, SKILL_LEFT);
REG_EVENT_TYPE(eGame, 22, SKILL_RIGHT);

REG_EVENT_TYPE(eGame, 23, HP_CHANGE);
REG_EVENT_TYPE(eGame, 24, MP_CHANGE);

REG_EVENT_TYPE(eGame, 25, MP_NOTENOUGH);

REG_EVENT_TYPE(eGame, 26, EVENTS_ACTION);
REG_EVENT_TYPE(eGame, 27, EVENTS_ATTACK);

// 是否退出游戏
REG_EVENT_TYPE(eGame, 28, EXIT_GAME);
// 是否播放gogogo
REG_EVENT_TYPE(eGame, 29, EVENTS_GOGOGO);

// BOSS死亡一瞬间了
REG_EVENT_TYPE(eGame, 30, IZ_BOSSDEAD);
// Disappear瞬间
REG_EVENT_TYPE(eGame, 31, ROLE_DISAPPEAR);
// 新手教程移动结束的事件
REG_EVENT_TYPE(eGame, 32, GUILD_MOVEEND);

// GC1触发
REG_EVENT_TYPE(eGame, 33, SKILL_NORMAL);

// 点击NPC中途停止
REG_EVENT_TYPE(eGame, 34, CITY_TOUCH_STOP);
// 玩家复活事件
REG_EVENT_TYPE(eGame, 35, EVENT_ONREVIVE);
// SDK登录成功的消息
REG_EVENT_TYPE(eGame, 36, EVENT_SDKLOGIN_SUC);
// 显示设置界面
REG_EVENT_TYPE(eGame, 40, SHOW_SETTING);
// 副本阶段切换
REG_EVENT_TYPE(eGame, 41, IZ_STAGE_CHANGE);
// 检查网路等待
REG_EVENT_TYPE(eGame, 42, NET_WAITING_CHECK);
// 检查网路等待
REG_EVENT_TYPE(eGame, 43, NET_WAITING_CLEAR);
// 断线重连
REG_EVENT_TYPE(eGame, 44, RECONNECT_EVENT);
// 充值事件
REG_EVENT_TYPE(eGame, 45, CHARGE_EVENT);
// 重新登录切换状态机
REG_EVENT_TYPE(eGame, 46, RELOADGAME_CHANGESTATE);

// BaseWindow
REG_EVENT_TYPE(eUI, 0, EFFECT_END);
REG_EVENT_TYPE(eUI, 1, WINDOW_TOUCHENABLE);

// Button
REG_EVENT_TYPE(eUI, 3, BUTTON_DOWN);
REG_EVENT_TYPE(eUI, 4, BUTTON_UP);
REG_EVENT_TYPE(eUI, 5, BUTTON_CLICK);
REG_EVENT_TYPE(eUI, 6, BUTTON_MOVEEND);
REG_EVENT_TYPE(eUI, 7, BUTTON_TOUCH);

//RadioButton
REG_EVENT_TYPE(eUI, 8, SELECT_CHANGED);

//ItemWindow
REG_EVENT_TYPE(eUI, 10, ITEMWINDOW_DOWN);
REG_EVENT_TYPE(eUI, 11, ITEMWINDOW_UP);
REG_EVENT_TYPE(eUI, 12, ITEMWINDOW_CLICK);
REG_EVENT_TYPE(eUI, 13, ITEMWINDOW_CDOUT);

//Scrollbar
REG_EVENT_TYPE(eUI, 15, SCROLLBAR_TURNOVER);
REG_EVENT_TYPE(eUI, 16, SCROLLBAR_STAYWINDOW);

// linker
REG_EVENT_TYPE(eUI, 18, LINKER_SELECT);

// TimerLable
REG_EVENT_TYPE(eUI, 25, TIMEROUT);

// XWheelWindow
REG_EVENT_TYPE(eUI, 26, WHELL_END);

// MigicWindow
REG_EVENT_TYPE(eUI, 29, MIGIC_END);

// XNoticeLabel
REG_EVENT_TYPE(eUI, 31, NOTICE_FADEOUT);

//XImageNum
REG_EVENT_TYPE(eUI, 32, IMAGENUM_OVER);

// FuncPanel
REG_EVENT_TYPE(eUI, 35, FUNCPANEL_DOWN);
REG_EVENT_TYPE(eUI, 36, FUNCPANEL_UP);
REG_EVENT_TYPE(eUI, 37, FUNCPANEL_CLICK);
REG_EVENT_TYPE(eUI, 38, FUNCPANEL_MOVEEND);
REG_EVENT_TYPE(eUI, 39, FUNCPANEL_MOVEEVENT);

// XLabel
REG_EVENT_TYPE(eUI, 40, XLABLE_SHOWALL);

// XSlider
REG_EVENT_TYPE(eUI, 43, XSLIDER_CHANGED);

// XProssBar
REG_EVENT_TYPE(eUI, 45, XPROSSBAR_ADDNUMEND);

// 控件放大后的事件
REG_EVENT_TYPE(eUI, 46, XWINDOW_SCALE);

// XUIRole
REG_EVENT_TYPE(eUI, 50, XUIROLE_MOVEEND);

};

#endif